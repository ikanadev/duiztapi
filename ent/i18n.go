// Code generated by entc, DO NOT EDIT.

package ent

import (
	"fmt"
	"strings"

	"github.com/facebook/ent/dialect/sql"
	"github.com/vmkevv/duiztapi/ent/i18n"
)

// I18n is the model entity for the I18n schema.
type I18n struct {
	config `json:"-"`
	// ID of the ent.
	ID int `json:"id,omitempty"`
	// Code holds the value of the "code" field.
	Code string `json:"code,omitempty"`
	// Language holds the value of the "language" field.
	Language string `json:"language,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the I18nQuery when eager-loading is set.
	Edges I18nEdges `json:"edges"`
}

// I18nEdges holds the relations/edges for other nodes in the graph.
type I18nEdges struct {
	// AnswerLangs holds the value of the answer_langs edge.
	AnswerLangs []*AnswerLangs
	// QuestionLangs holds the value of the question_langs edge.
	QuestionLangs []*QuestionLangs
	// QuizLangs holds the value of the quiz_langs edge.
	QuizLangs []*QuizLangs
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [3]bool
}

// AnswerLangsOrErr returns the AnswerLangs value or an error if the edge
// was not loaded in eager-loading.
func (e I18nEdges) AnswerLangsOrErr() ([]*AnswerLangs, error) {
	if e.loadedTypes[0] {
		return e.AnswerLangs, nil
	}
	return nil, &NotLoadedError{edge: "answer_langs"}
}

// QuestionLangsOrErr returns the QuestionLangs value or an error if the edge
// was not loaded in eager-loading.
func (e I18nEdges) QuestionLangsOrErr() ([]*QuestionLangs, error) {
	if e.loadedTypes[1] {
		return e.QuestionLangs, nil
	}
	return nil, &NotLoadedError{edge: "question_langs"}
}

// QuizLangsOrErr returns the QuizLangs value or an error if the edge
// was not loaded in eager-loading.
func (e I18nEdges) QuizLangsOrErr() ([]*QuizLangs, error) {
	if e.loadedTypes[2] {
		return e.QuizLangs, nil
	}
	return nil, &NotLoadedError{edge: "quiz_langs"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*I18n) scanValues(columns []string) ([]interface{}, error) {
	values := make([]interface{}, len(columns))
	for i := range columns {
		switch columns[i] {
		case i18n.FieldID:
			values[i] = &sql.NullInt64{}
		case i18n.FieldCode, i18n.FieldLanguage:
			values[i] = &sql.NullString{}
		default:
			return nil, fmt.Errorf("unexpected column %q for type I18n", columns[i])
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the I18n fields.
func (i *I18n) assignValues(columns []string, values []interface{}) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for j := range columns {
		switch columns[j] {
		case i18n.FieldID:
			value, ok := values[j].(*sql.NullInt64)
			if !ok {
				return fmt.Errorf("unexpected type %T for field id", value)
			}
			i.ID = int(value.Int64)
		case i18n.FieldCode:
			if value, ok := values[j].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field code", values[j])
			} else if value.Valid {
				i.Code = value.String
			}
		case i18n.FieldLanguage:
			if value, ok := values[j].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field language", values[j])
			} else if value.Valid {
				i.Language = value.String
			}
		}
	}
	return nil
}

// QueryAnswerLangs queries the "answer_langs" edge of the I18n entity.
func (i *I18n) QueryAnswerLangs() *AnswerLangsQuery {
	return (&I18nClient{config: i.config}).QueryAnswerLangs(i)
}

// QueryQuestionLangs queries the "question_langs" edge of the I18n entity.
func (i *I18n) QueryQuestionLangs() *QuestionLangsQuery {
	return (&I18nClient{config: i.config}).QueryQuestionLangs(i)
}

// QueryQuizLangs queries the "quiz_langs" edge of the I18n entity.
func (i *I18n) QueryQuizLangs() *QuizLangsQuery {
	return (&I18nClient{config: i.config}).QueryQuizLangs(i)
}

// Update returns a builder for updating this I18n.
// Note that you need to call I18n.Unwrap() before calling this method if this I18n
// was returned from a transaction, and the transaction was committed or rolled back.
func (i *I18n) Update() *I18nUpdateOne {
	return (&I18nClient{config: i.config}).UpdateOne(i)
}

// Unwrap unwraps the I18n entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (i *I18n) Unwrap() *I18n {
	tx, ok := i.config.driver.(*txDriver)
	if !ok {
		panic("ent: I18n is not a transactional entity")
	}
	i.config.driver = tx.drv
	return i
}

// String implements the fmt.Stringer.
func (i *I18n) String() string {
	var builder strings.Builder
	builder.WriteString("I18n(")
	builder.WriteString(fmt.Sprintf("id=%v", i.ID))
	builder.WriteString(", code=")
	builder.WriteString(i.Code)
	builder.WriteString(", language=")
	builder.WriteString(i.Language)
	builder.WriteByte(')')
	return builder.String()
}

// I18ns is a parsable slice of I18n.
type I18ns []*I18n

func (i I18ns) config(cfg config) {
	for _i := range i {
		i[_i].config = cfg
	}
}
