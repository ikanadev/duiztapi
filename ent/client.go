// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"log"

	"github.com/vmkevv/duiztapi/ent/migrate"

	"github.com/vmkevv/duiztapi/ent/answer"
	"github.com/vmkevv/duiztapi/ent/answerlangs"
	"github.com/vmkevv/duiztapi/ent/i18n"
	"github.com/vmkevv/duiztapi/ent/question"
	"github.com/vmkevv/duiztapi/ent/questionlangs"
	"github.com/vmkevv/duiztapi/ent/quiz"
	"github.com/vmkevv/duiztapi/ent/quizlangs"
	"github.com/vmkevv/duiztapi/ent/response"
	"github.com/vmkevv/duiztapi/ent/user"

	"github.com/facebook/ent/dialect"
	"github.com/facebook/ent/dialect/sql"
	"github.com/facebook/ent/dialect/sql/sqlgraph"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Answer is the client for interacting with the Answer builders.
	Answer *AnswerClient
	// AnswerLangs is the client for interacting with the AnswerLangs builders.
	AnswerLangs *AnswerLangsClient
	// I18n is the client for interacting with the I18n builders.
	I18n *I18nClient
	// Question is the client for interacting with the Question builders.
	Question *QuestionClient
	// QuestionLangs is the client for interacting with the QuestionLangs builders.
	QuestionLangs *QuestionLangsClient
	// Quiz is the client for interacting with the Quiz builders.
	Quiz *QuizClient
	// QuizLangs is the client for interacting with the QuizLangs builders.
	QuizLangs *QuizLangsClient
	// Response is the client for interacting with the Response builders.
	Response *ResponseClient
	// User is the client for interacting with the User builders.
	User *UserClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	cfg := config{log: log.Println, hooks: &hooks{}}
	cfg.options(opts...)
	client := &Client{config: cfg}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Answer = NewAnswerClient(c.config)
	c.AnswerLangs = NewAnswerLangsClient(c.config)
	c.I18n = NewI18nClient(c.config)
	c.Question = NewQuestionClient(c.config)
	c.QuestionLangs = NewQuestionLangsClient(c.config)
	c.Quiz = NewQuizClient(c.config)
	c.QuizLangs = NewQuizLangsClient(c.config)
	c.Response = NewResponseClient(c.config)
	c.User = NewUserClient(c.config)
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, fmt.Errorf("ent: cannot start a transaction within a transaction")
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %v", err)
	}
	cfg := config{driver: tx, log: c.log, debug: c.debug, hooks: c.hooks}
	return &Tx{
		ctx:           ctx,
		config:        cfg,
		Answer:        NewAnswerClient(cfg),
		AnswerLangs:   NewAnswerLangsClient(cfg),
		I18n:          NewI18nClient(cfg),
		Question:      NewQuestionClient(cfg),
		QuestionLangs: NewQuestionLangsClient(cfg),
		Quiz:          NewQuizClient(cfg),
		QuizLangs:     NewQuizLangsClient(cfg),
		Response:      NewResponseClient(cfg),
		User:          NewUserClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, fmt.Errorf("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(*sql.Driver).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %v", err)
	}
	cfg := config{driver: &txDriver{tx: tx, drv: c.driver}, log: c.log, debug: c.debug, hooks: c.hooks}
	return &Tx{
		config:        cfg,
		Answer:        NewAnswerClient(cfg),
		AnswerLangs:   NewAnswerLangsClient(cfg),
		I18n:          NewI18nClient(cfg),
		Question:      NewQuestionClient(cfg),
		QuestionLangs: NewQuestionLangsClient(cfg),
		Quiz:          NewQuizClient(cfg),
		QuizLangs:     NewQuizLangsClient(cfg),
		Response:      NewResponseClient(cfg),
		User:          NewUserClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Answer.
//		Query().
//		Count(ctx)
//
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := config{driver: dialect.Debug(c.driver, c.log), log: c.log, debug: true, hooks: c.hooks}
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	c.Answer.Use(hooks...)
	c.AnswerLangs.Use(hooks...)
	c.I18n.Use(hooks...)
	c.Question.Use(hooks...)
	c.QuestionLangs.Use(hooks...)
	c.Quiz.Use(hooks...)
	c.QuizLangs.Use(hooks...)
	c.Response.Use(hooks...)
	c.User.Use(hooks...)
}

// AnswerClient is a client for the Answer schema.
type AnswerClient struct {
	config
}

// NewAnswerClient returns a client for the Answer from the given config.
func NewAnswerClient(c config) *AnswerClient {
	return &AnswerClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `answer.Hooks(f(g(h())))`.
func (c *AnswerClient) Use(hooks ...Hook) {
	c.hooks.Answer = append(c.hooks.Answer, hooks...)
}

// Create returns a create builder for Answer.
func (c *AnswerClient) Create() *AnswerCreate {
	mutation := newAnswerMutation(c.config, OpCreate)
	return &AnswerCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Answer entities.
func (c *AnswerClient) CreateBulk(builders ...*AnswerCreate) *AnswerCreateBulk {
	return &AnswerCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Answer.
func (c *AnswerClient) Update() *AnswerUpdate {
	mutation := newAnswerMutation(c.config, OpUpdate)
	return &AnswerUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AnswerClient) UpdateOne(a *Answer) *AnswerUpdateOne {
	mutation := newAnswerMutation(c.config, OpUpdateOne, withAnswer(a))
	return &AnswerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AnswerClient) UpdateOneID(id int) *AnswerUpdateOne {
	mutation := newAnswerMutation(c.config, OpUpdateOne, withAnswerID(id))
	return &AnswerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Answer.
func (c *AnswerClient) Delete() *AnswerDelete {
	mutation := newAnswerMutation(c.config, OpDelete)
	return &AnswerDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *AnswerClient) DeleteOne(a *Answer) *AnswerDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *AnswerClient) DeleteOneID(id int) *AnswerDeleteOne {
	builder := c.Delete().Where(answer.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AnswerDeleteOne{builder}
}

// Query returns a query builder for Answer.
func (c *AnswerClient) Query() *AnswerQuery {
	return &AnswerQuery{config: c.config}
}

// Get returns a Answer entity by its id.
func (c *AnswerClient) Get(ctx context.Context, id int) (*Answer, error) {
	return c.Query().Where(answer.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AnswerClient) GetX(ctx context.Context, id int) *Answer {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryLangs queries the langs edge of a Answer.
func (c *AnswerClient) QueryLangs(a *Answer) *AnswerLangsQuery {
	query := &AnswerLangsQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(answer.Table, answer.FieldID, id),
			sqlgraph.To(answerlangs.Table, answerlangs.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, answer.LangsTable, answer.LangsColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryResponses queries the responses edge of a Answer.
func (c *AnswerClient) QueryResponses(a *Answer) *ResponseQuery {
	query := &ResponseQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(answer.Table, answer.FieldID, id),
			sqlgraph.To(response.Table, response.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, answer.ResponsesTable, answer.ResponsesColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryQuestion queries the question edge of a Answer.
func (c *AnswerClient) QueryQuestion(a *Answer) *QuestionQuery {
	query := &QuestionQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(answer.Table, answer.FieldID, id),
			sqlgraph.To(question.Table, question.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, answer.QuestionTable, answer.QuestionColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AnswerClient) Hooks() []Hook {
	return c.hooks.Answer
}

// AnswerLangsClient is a client for the AnswerLangs schema.
type AnswerLangsClient struct {
	config
}

// NewAnswerLangsClient returns a client for the AnswerLangs from the given config.
func NewAnswerLangsClient(c config) *AnswerLangsClient {
	return &AnswerLangsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `answerlangs.Hooks(f(g(h())))`.
func (c *AnswerLangsClient) Use(hooks ...Hook) {
	c.hooks.AnswerLangs = append(c.hooks.AnswerLangs, hooks...)
}

// Create returns a create builder for AnswerLangs.
func (c *AnswerLangsClient) Create() *AnswerLangsCreate {
	mutation := newAnswerLangsMutation(c.config, OpCreate)
	return &AnswerLangsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AnswerLangs entities.
func (c *AnswerLangsClient) CreateBulk(builders ...*AnswerLangsCreate) *AnswerLangsCreateBulk {
	return &AnswerLangsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AnswerLangs.
func (c *AnswerLangsClient) Update() *AnswerLangsUpdate {
	mutation := newAnswerLangsMutation(c.config, OpUpdate)
	return &AnswerLangsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AnswerLangsClient) UpdateOne(al *AnswerLangs) *AnswerLangsUpdateOne {
	mutation := newAnswerLangsMutation(c.config, OpUpdateOne, withAnswerLangs(al))
	return &AnswerLangsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AnswerLangsClient) UpdateOneID(id int) *AnswerLangsUpdateOne {
	mutation := newAnswerLangsMutation(c.config, OpUpdateOne, withAnswerLangsID(id))
	return &AnswerLangsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AnswerLangs.
func (c *AnswerLangsClient) Delete() *AnswerLangsDelete {
	mutation := newAnswerLangsMutation(c.config, OpDelete)
	return &AnswerLangsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *AnswerLangsClient) DeleteOne(al *AnswerLangs) *AnswerLangsDeleteOne {
	return c.DeleteOneID(al.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *AnswerLangsClient) DeleteOneID(id int) *AnswerLangsDeleteOne {
	builder := c.Delete().Where(answerlangs.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AnswerLangsDeleteOne{builder}
}

// Query returns a query builder for AnswerLangs.
func (c *AnswerLangsClient) Query() *AnswerLangsQuery {
	return &AnswerLangsQuery{config: c.config}
}

// Get returns a AnswerLangs entity by its id.
func (c *AnswerLangsClient) Get(ctx context.Context, id int) (*AnswerLangs, error) {
	return c.Query().Where(answerlangs.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AnswerLangsClient) GetX(ctx context.Context, id int) *AnswerLangs {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAnswer queries the answer edge of a AnswerLangs.
func (c *AnswerLangsClient) QueryAnswer(al *AnswerLangs) *AnswerQuery {
	query := &AnswerQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := al.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(answerlangs.Table, answerlangs.FieldID, id),
			sqlgraph.To(answer.Table, answer.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, answerlangs.AnswerTable, answerlangs.AnswerColumn),
		)
		fromV = sqlgraph.Neighbors(al.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryI18n queries the i18n edge of a AnswerLangs.
func (c *AnswerLangsClient) QueryI18n(al *AnswerLangs) *I18nQuery {
	query := &I18nQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := al.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(answerlangs.Table, answerlangs.FieldID, id),
			sqlgraph.To(i18n.Table, i18n.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, answerlangs.I18nTable, answerlangs.I18nColumn),
		)
		fromV = sqlgraph.Neighbors(al.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AnswerLangsClient) Hooks() []Hook {
	return c.hooks.AnswerLangs
}

// I18nClient is a client for the I18n schema.
type I18nClient struct {
	config
}

// NewI18nClient returns a client for the I18n from the given config.
func NewI18nClient(c config) *I18nClient {
	return &I18nClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `i18n.Hooks(f(g(h())))`.
func (c *I18nClient) Use(hooks ...Hook) {
	c.hooks.I18n = append(c.hooks.I18n, hooks...)
}

// Create returns a create builder for I18n.
func (c *I18nClient) Create() *I18nCreate {
	mutation := newI18nMutation(c.config, OpCreate)
	return &I18nCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of I18n entities.
func (c *I18nClient) CreateBulk(builders ...*I18nCreate) *I18nCreateBulk {
	return &I18nCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for I18n.
func (c *I18nClient) Update() *I18nUpdate {
	mutation := newI18nMutation(c.config, OpUpdate)
	return &I18nUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *I18nClient) UpdateOne(i *I18n) *I18nUpdateOne {
	mutation := newI18nMutation(c.config, OpUpdateOne, withI18n(i))
	return &I18nUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *I18nClient) UpdateOneID(id int) *I18nUpdateOne {
	mutation := newI18nMutation(c.config, OpUpdateOne, withI18nID(id))
	return &I18nUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for I18n.
func (c *I18nClient) Delete() *I18nDelete {
	mutation := newI18nMutation(c.config, OpDelete)
	return &I18nDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *I18nClient) DeleteOne(i *I18n) *I18nDeleteOne {
	return c.DeleteOneID(i.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *I18nClient) DeleteOneID(id int) *I18nDeleteOne {
	builder := c.Delete().Where(i18n.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &I18nDeleteOne{builder}
}

// Query returns a query builder for I18n.
func (c *I18nClient) Query() *I18nQuery {
	return &I18nQuery{config: c.config}
}

// Get returns a I18n entity by its id.
func (c *I18nClient) Get(ctx context.Context, id int) (*I18n, error) {
	return c.Query().Where(i18n.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *I18nClient) GetX(ctx context.Context, id int) *I18n {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAnswerLangs queries the answer_langs edge of a I18n.
func (c *I18nClient) QueryAnswerLangs(i *I18n) *AnswerLangsQuery {
	query := &AnswerLangsQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(i18n.Table, i18n.FieldID, id),
			sqlgraph.To(answerlangs.Table, answerlangs.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, i18n.AnswerLangsTable, i18n.AnswerLangsColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryQuestionLangs queries the question_langs edge of a I18n.
func (c *I18nClient) QueryQuestionLangs(i *I18n) *QuestionLangsQuery {
	query := &QuestionLangsQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(i18n.Table, i18n.FieldID, id),
			sqlgraph.To(questionlangs.Table, questionlangs.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, i18n.QuestionLangsTable, i18n.QuestionLangsColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryQuizLangs queries the quiz_langs edge of a I18n.
func (c *I18nClient) QueryQuizLangs(i *I18n) *QuizLangsQuery {
	query := &QuizLangsQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(i18n.Table, i18n.FieldID, id),
			sqlgraph.To(quizlangs.Table, quizlangs.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, i18n.QuizLangsTable, i18n.QuizLangsColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *I18nClient) Hooks() []Hook {
	return c.hooks.I18n
}

// QuestionClient is a client for the Question schema.
type QuestionClient struct {
	config
}

// NewQuestionClient returns a client for the Question from the given config.
func NewQuestionClient(c config) *QuestionClient {
	return &QuestionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `question.Hooks(f(g(h())))`.
func (c *QuestionClient) Use(hooks ...Hook) {
	c.hooks.Question = append(c.hooks.Question, hooks...)
}

// Create returns a create builder for Question.
func (c *QuestionClient) Create() *QuestionCreate {
	mutation := newQuestionMutation(c.config, OpCreate)
	return &QuestionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Question entities.
func (c *QuestionClient) CreateBulk(builders ...*QuestionCreate) *QuestionCreateBulk {
	return &QuestionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Question.
func (c *QuestionClient) Update() *QuestionUpdate {
	mutation := newQuestionMutation(c.config, OpUpdate)
	return &QuestionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *QuestionClient) UpdateOne(q *Question) *QuestionUpdateOne {
	mutation := newQuestionMutation(c.config, OpUpdateOne, withQuestion(q))
	return &QuestionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *QuestionClient) UpdateOneID(id int) *QuestionUpdateOne {
	mutation := newQuestionMutation(c.config, OpUpdateOne, withQuestionID(id))
	return &QuestionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Question.
func (c *QuestionClient) Delete() *QuestionDelete {
	mutation := newQuestionMutation(c.config, OpDelete)
	return &QuestionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *QuestionClient) DeleteOne(q *Question) *QuestionDeleteOne {
	return c.DeleteOneID(q.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *QuestionClient) DeleteOneID(id int) *QuestionDeleteOne {
	builder := c.Delete().Where(question.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &QuestionDeleteOne{builder}
}

// Query returns a query builder for Question.
func (c *QuestionClient) Query() *QuestionQuery {
	return &QuestionQuery{config: c.config}
}

// Get returns a Question entity by its id.
func (c *QuestionClient) Get(ctx context.Context, id int) (*Question, error) {
	return c.Query().Where(question.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *QuestionClient) GetX(ctx context.Context, id int) *Question {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAnswers queries the answers edge of a Question.
func (c *QuestionClient) QueryAnswers(q *Question) *AnswerQuery {
	query := &AnswerQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := q.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(question.Table, question.FieldID, id),
			sqlgraph.To(answer.Table, answer.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, question.AnswersTable, question.AnswersColumn),
		)
		fromV = sqlgraph.Neighbors(q.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLangs queries the langs edge of a Question.
func (c *QuestionClient) QueryLangs(q *Question) *QuestionLangsQuery {
	query := &QuestionLangsQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := q.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(question.Table, question.FieldID, id),
			sqlgraph.To(questionlangs.Table, questionlangs.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, question.LangsTable, question.LangsColumn),
		)
		fromV = sqlgraph.Neighbors(q.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryQuiz queries the quiz edge of a Question.
func (c *QuestionClient) QueryQuiz(q *Question) *QuizQuery {
	query := &QuizQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := q.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(question.Table, question.FieldID, id),
			sqlgraph.To(quiz.Table, quiz.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, question.QuizTable, question.QuizColumn),
		)
		fromV = sqlgraph.Neighbors(q.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCorrectAnswer queries the correct_answer edge of a Question.
func (c *QuestionClient) QueryCorrectAnswer(q *Question) *AnswerQuery {
	query := &AnswerQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := q.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(question.Table, question.FieldID, id),
			sqlgraph.To(answer.Table, answer.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, question.CorrectAnswerTable, question.CorrectAnswerColumn),
		)
		fromV = sqlgraph.Neighbors(q.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *QuestionClient) Hooks() []Hook {
	return c.hooks.Question
}

// QuestionLangsClient is a client for the QuestionLangs schema.
type QuestionLangsClient struct {
	config
}

// NewQuestionLangsClient returns a client for the QuestionLangs from the given config.
func NewQuestionLangsClient(c config) *QuestionLangsClient {
	return &QuestionLangsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `questionlangs.Hooks(f(g(h())))`.
func (c *QuestionLangsClient) Use(hooks ...Hook) {
	c.hooks.QuestionLangs = append(c.hooks.QuestionLangs, hooks...)
}

// Create returns a create builder for QuestionLangs.
func (c *QuestionLangsClient) Create() *QuestionLangsCreate {
	mutation := newQuestionLangsMutation(c.config, OpCreate)
	return &QuestionLangsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of QuestionLangs entities.
func (c *QuestionLangsClient) CreateBulk(builders ...*QuestionLangsCreate) *QuestionLangsCreateBulk {
	return &QuestionLangsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for QuestionLangs.
func (c *QuestionLangsClient) Update() *QuestionLangsUpdate {
	mutation := newQuestionLangsMutation(c.config, OpUpdate)
	return &QuestionLangsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *QuestionLangsClient) UpdateOne(ql *QuestionLangs) *QuestionLangsUpdateOne {
	mutation := newQuestionLangsMutation(c.config, OpUpdateOne, withQuestionLangs(ql))
	return &QuestionLangsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *QuestionLangsClient) UpdateOneID(id int) *QuestionLangsUpdateOne {
	mutation := newQuestionLangsMutation(c.config, OpUpdateOne, withQuestionLangsID(id))
	return &QuestionLangsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for QuestionLangs.
func (c *QuestionLangsClient) Delete() *QuestionLangsDelete {
	mutation := newQuestionLangsMutation(c.config, OpDelete)
	return &QuestionLangsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *QuestionLangsClient) DeleteOne(ql *QuestionLangs) *QuestionLangsDeleteOne {
	return c.DeleteOneID(ql.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *QuestionLangsClient) DeleteOneID(id int) *QuestionLangsDeleteOne {
	builder := c.Delete().Where(questionlangs.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &QuestionLangsDeleteOne{builder}
}

// Query returns a query builder for QuestionLangs.
func (c *QuestionLangsClient) Query() *QuestionLangsQuery {
	return &QuestionLangsQuery{config: c.config}
}

// Get returns a QuestionLangs entity by its id.
func (c *QuestionLangsClient) Get(ctx context.Context, id int) (*QuestionLangs, error) {
	return c.Query().Where(questionlangs.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *QuestionLangsClient) GetX(ctx context.Context, id int) *QuestionLangs {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryI18n queries the i18n edge of a QuestionLangs.
func (c *QuestionLangsClient) QueryI18n(ql *QuestionLangs) *I18nQuery {
	query := &I18nQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := ql.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(questionlangs.Table, questionlangs.FieldID, id),
			sqlgraph.To(i18n.Table, i18n.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, questionlangs.I18nTable, questionlangs.I18nColumn),
		)
		fromV = sqlgraph.Neighbors(ql.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryQuestion queries the question edge of a QuestionLangs.
func (c *QuestionLangsClient) QueryQuestion(ql *QuestionLangs) *QuestionQuery {
	query := &QuestionQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := ql.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(questionlangs.Table, questionlangs.FieldID, id),
			sqlgraph.To(question.Table, question.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, questionlangs.QuestionTable, questionlangs.QuestionColumn),
		)
		fromV = sqlgraph.Neighbors(ql.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *QuestionLangsClient) Hooks() []Hook {
	return c.hooks.QuestionLangs
}

// QuizClient is a client for the Quiz schema.
type QuizClient struct {
	config
}

// NewQuizClient returns a client for the Quiz from the given config.
func NewQuizClient(c config) *QuizClient {
	return &QuizClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `quiz.Hooks(f(g(h())))`.
func (c *QuizClient) Use(hooks ...Hook) {
	c.hooks.Quiz = append(c.hooks.Quiz, hooks...)
}

// Create returns a create builder for Quiz.
func (c *QuizClient) Create() *QuizCreate {
	mutation := newQuizMutation(c.config, OpCreate)
	return &QuizCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Quiz entities.
func (c *QuizClient) CreateBulk(builders ...*QuizCreate) *QuizCreateBulk {
	return &QuizCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Quiz.
func (c *QuizClient) Update() *QuizUpdate {
	mutation := newQuizMutation(c.config, OpUpdate)
	return &QuizUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *QuizClient) UpdateOne(q *Quiz) *QuizUpdateOne {
	mutation := newQuizMutation(c.config, OpUpdateOne, withQuiz(q))
	return &QuizUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *QuizClient) UpdateOneID(id int) *QuizUpdateOne {
	mutation := newQuizMutation(c.config, OpUpdateOne, withQuizID(id))
	return &QuizUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Quiz.
func (c *QuizClient) Delete() *QuizDelete {
	mutation := newQuizMutation(c.config, OpDelete)
	return &QuizDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *QuizClient) DeleteOne(q *Quiz) *QuizDeleteOne {
	return c.DeleteOneID(q.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *QuizClient) DeleteOneID(id int) *QuizDeleteOne {
	builder := c.Delete().Where(quiz.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &QuizDeleteOne{builder}
}

// Query returns a query builder for Quiz.
func (c *QuizClient) Query() *QuizQuery {
	return &QuizQuery{config: c.config}
}

// Get returns a Quiz entity by its id.
func (c *QuizClient) Get(ctx context.Context, id int) (*Quiz, error) {
	return c.Query().Where(quiz.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *QuizClient) GetX(ctx context.Context, id int) *Quiz {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryQuestions queries the questions edge of a Quiz.
func (c *QuizClient) QueryQuestions(q *Quiz) *QuestionQuery {
	query := &QuestionQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := q.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(quiz.Table, quiz.FieldID, id),
			sqlgraph.To(question.Table, question.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, quiz.QuestionsTable, quiz.QuestionsColumn),
		)
		fromV = sqlgraph.Neighbors(q.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLangs queries the langs edge of a Quiz.
func (c *QuizClient) QueryLangs(q *Quiz) *QuizLangsQuery {
	query := &QuizLangsQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := q.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(quiz.Table, quiz.FieldID, id),
			sqlgraph.To(quizlangs.Table, quizlangs.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, quiz.LangsTable, quiz.LangsColumn),
		)
		fromV = sqlgraph.Neighbors(q.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUsers queries the users edge of a Quiz.
func (c *QuizClient) QueryUsers(q *Quiz) *UserQuery {
	query := &UserQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := q.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(quiz.Table, quiz.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, quiz.UsersTable, quiz.UsersPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(q.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *QuizClient) Hooks() []Hook {
	return c.hooks.Quiz
}

// QuizLangsClient is a client for the QuizLangs schema.
type QuizLangsClient struct {
	config
}

// NewQuizLangsClient returns a client for the QuizLangs from the given config.
func NewQuizLangsClient(c config) *QuizLangsClient {
	return &QuizLangsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `quizlangs.Hooks(f(g(h())))`.
func (c *QuizLangsClient) Use(hooks ...Hook) {
	c.hooks.QuizLangs = append(c.hooks.QuizLangs, hooks...)
}

// Create returns a create builder for QuizLangs.
func (c *QuizLangsClient) Create() *QuizLangsCreate {
	mutation := newQuizLangsMutation(c.config, OpCreate)
	return &QuizLangsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of QuizLangs entities.
func (c *QuizLangsClient) CreateBulk(builders ...*QuizLangsCreate) *QuizLangsCreateBulk {
	return &QuizLangsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for QuizLangs.
func (c *QuizLangsClient) Update() *QuizLangsUpdate {
	mutation := newQuizLangsMutation(c.config, OpUpdate)
	return &QuizLangsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *QuizLangsClient) UpdateOne(ql *QuizLangs) *QuizLangsUpdateOne {
	mutation := newQuizLangsMutation(c.config, OpUpdateOne, withQuizLangs(ql))
	return &QuizLangsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *QuizLangsClient) UpdateOneID(id int) *QuizLangsUpdateOne {
	mutation := newQuizLangsMutation(c.config, OpUpdateOne, withQuizLangsID(id))
	return &QuizLangsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for QuizLangs.
func (c *QuizLangsClient) Delete() *QuizLangsDelete {
	mutation := newQuizLangsMutation(c.config, OpDelete)
	return &QuizLangsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *QuizLangsClient) DeleteOne(ql *QuizLangs) *QuizLangsDeleteOne {
	return c.DeleteOneID(ql.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *QuizLangsClient) DeleteOneID(id int) *QuizLangsDeleteOne {
	builder := c.Delete().Where(quizlangs.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &QuizLangsDeleteOne{builder}
}

// Query returns a query builder for QuizLangs.
func (c *QuizLangsClient) Query() *QuizLangsQuery {
	return &QuizLangsQuery{config: c.config}
}

// Get returns a QuizLangs entity by its id.
func (c *QuizLangsClient) Get(ctx context.Context, id int) (*QuizLangs, error) {
	return c.Query().Where(quizlangs.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *QuizLangsClient) GetX(ctx context.Context, id int) *QuizLangs {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryQuiz queries the quiz edge of a QuizLangs.
func (c *QuizLangsClient) QueryQuiz(ql *QuizLangs) *QuizQuery {
	query := &QuizQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := ql.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(quizlangs.Table, quizlangs.FieldID, id),
			sqlgraph.To(quiz.Table, quiz.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, quizlangs.QuizTable, quizlangs.QuizColumn),
		)
		fromV = sqlgraph.Neighbors(ql.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryI18n queries the i18n edge of a QuizLangs.
func (c *QuizLangsClient) QueryI18n(ql *QuizLangs) *I18nQuery {
	query := &I18nQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := ql.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(quizlangs.Table, quizlangs.FieldID, id),
			sqlgraph.To(i18n.Table, i18n.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, quizlangs.I18nTable, quizlangs.I18nColumn),
		)
		fromV = sqlgraph.Neighbors(ql.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *QuizLangsClient) Hooks() []Hook {
	return c.hooks.QuizLangs
}

// ResponseClient is a client for the Response schema.
type ResponseClient struct {
	config
}

// NewResponseClient returns a client for the Response from the given config.
func NewResponseClient(c config) *ResponseClient {
	return &ResponseClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `response.Hooks(f(g(h())))`.
func (c *ResponseClient) Use(hooks ...Hook) {
	c.hooks.Response = append(c.hooks.Response, hooks...)
}

// Create returns a create builder for Response.
func (c *ResponseClient) Create() *ResponseCreate {
	mutation := newResponseMutation(c.config, OpCreate)
	return &ResponseCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Response entities.
func (c *ResponseClient) CreateBulk(builders ...*ResponseCreate) *ResponseCreateBulk {
	return &ResponseCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Response.
func (c *ResponseClient) Update() *ResponseUpdate {
	mutation := newResponseMutation(c.config, OpUpdate)
	return &ResponseUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ResponseClient) UpdateOne(r *Response) *ResponseUpdateOne {
	mutation := newResponseMutation(c.config, OpUpdateOne, withResponse(r))
	return &ResponseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ResponseClient) UpdateOneID(id int) *ResponseUpdateOne {
	mutation := newResponseMutation(c.config, OpUpdateOne, withResponseID(id))
	return &ResponseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Response.
func (c *ResponseClient) Delete() *ResponseDelete {
	mutation := newResponseMutation(c.config, OpDelete)
	return &ResponseDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *ResponseClient) DeleteOne(r *Response) *ResponseDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *ResponseClient) DeleteOneID(id int) *ResponseDeleteOne {
	builder := c.Delete().Where(response.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ResponseDeleteOne{builder}
}

// Query returns a query builder for Response.
func (c *ResponseClient) Query() *ResponseQuery {
	return &ResponseQuery{config: c.config}
}

// Get returns a Response entity by its id.
func (c *ResponseClient) Get(ctx context.Context, id int) (*Response, error) {
	return c.Query().Where(response.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ResponseClient) GetX(ctx context.Context, id int) *Response {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a Response.
func (c *ResponseClient) QueryUser(r *Response) *UserQuery {
	query := &UserQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(response.Table, response.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, response.UserTable, response.UserColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAnswer queries the answer edge of a Response.
func (c *ResponseClient) QueryAnswer(r *Response) *AnswerQuery {
	query := &AnswerQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(response.Table, response.FieldID, id),
			sqlgraph.To(answer.Table, answer.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, response.AnswerTable, response.AnswerColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ResponseClient) Hooks() []Hook {
	return c.hooks.Response
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Create returns a create builder for User.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(u *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(u))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id int) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *UserClient) DeleteOne(u *User) *UserDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *UserClient) DeleteOneID(id int) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{config: c.config}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id int) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id int) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryResponses queries the responses edge of a User.
func (c *UserClient) QueryResponses(u *User) *ResponseQuery {
	query := &ResponseQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(response.Table, response.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.ResponsesTable, user.ResponsesColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryQuizes queries the quizes edge of a User.
func (c *UserClient) QueryQuizes(u *User) *QuizQuery {
	query := &QuizQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(quiz.Table, quiz.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, user.QuizesTable, user.QuizesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}
